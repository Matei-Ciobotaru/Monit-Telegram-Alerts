###############################################################################
## Monit control file
###############################################################################
##
## Comments begin with a '#' and extend through the end of the line. Keywords
## are case insensitive. All path's MUST BE FULLY QUALIFIED, starting with '/'.
##
## Below you will find examples of some frequently used statements. For
## information about the control file and a complete list of statements and
## options, please have a look in the Monit manual.
##
##
###############################################################################
## Global section
###############################################################################
##
## Start Monit in the background (run as a daemon):
#
  set daemon 60            # check services at 2-minute intervals
#   with start delay 240    # optional: delay the first check by 4-minutes (by
#                           # default Monit check immediately after Monit start)
#
#
## Set syslog logging. If you want to log to a standalone log file instead,
## specify the full path to the log file
#
  set logfile /var/log/monit.log
#
#
## Set the location of the Monit lock file which stores the process id of the
## running Monit instance. By default this file is stored in $HOME/.monit.pid
#
 set pidfile /var/run/monit.pid
#
## Set the location of the Monit id file which stores the unique id for the
## Monit instance. The id is generated and stored on first Monit start. By
## default the file is placed in $HOME/.monit.id.
#
# set idfile /var/.monit.id
  set idfile /var/lib/monit/id
#
## Set the location of the Monit state file which saves monitoring states
## on each cycle. By default the file is placed in $HOME/.monit.state. If
## the state file is stored on a persistent filesystem, Monit will recover
## the monitoring state across reboots. If it is on temporary filesystem, the
## state will be lost on reboot which may be convenient in some situations.
#
  set statefile /var/lib/monit/state
#
#

## Set limits for various tests. The following example shows the default values:
##
# set limits {
#     programOutput:     512 B,      # check program's output truncate limit
#     sendExpectBuffer:  256 B,      # limit for send/expect protocol test
#     fileContentBuffer: 512 B,      # limit for file content test
#     httpContentBuffer: 1 MB,       # limit for HTTP content test
#     networkTimeout:    5 seconds   # timeout for network I/O
#     programTimeout:    300 seconds # timeout for check program
#     stopTimeout:       30 seconds  # timeout for service stop
#     startTimeout:      30 seconds  # timeout for service start
#     restartTimeout:    30 seconds  # timeout for service restart
# }

## Set global SSL options (just most common options showed, see manual for
## full list).
#
# set ssl {
#     verify     : enable, # verify SSL certificates (disabled by default but STRONGLY RECOMMENDED)
#     selfsigned : allow   # allow self signed SSL certificates (reject by default)
# }
#
#
## Set the list of mail servers for alert delivery. Multiple servers may be
## specified using a comma separator. If the first mail server fails, Monit
# will use the second mail server in the list and so on. By default Monit uses
# port 25 - it is possible to override this with the PORT option.
#
# set mailserver mail.bar.baz,               # primary mailserver
#                backup.bar.baz port 10025,  # backup mailserver on port 10025
#                localhost                   # fallback relay
#
#
## By default Monit will drop alert events if no mail servers are available.
## If you want to keep the alerts for later delivery retry, you can use the
## EVENTQUEUE statement. The base directory where undelivered alerts will be
## stored is specified by the BASEDIR option. You can limit the queue size
## by using the SLOTS option (if omitted, the queue is limited by space
## available in the back end filesystem).
#
  set eventqueue
      basedir /var/lib/monit/events # set the base directory where events will be stored
      slots 100                     # optionally limit the queue size
#
#
## Send status and events to M/Monit (for more informations about M/Monit
## see https://mmonit.com/). By default Monit registers credentials with
## M/Monit so M/Monit can smoothly communicate back to Monit and you don't
## have to register Monit credentials manually in M/Monit. It is possible to
## disable credential registration using the commented out option below.
## Though, if safety is a concern we recommend instead using https when
## communicating with M/Monit and send credentials encrypted. The password
## should be URL encoded if it contains URL-significant characters like
## ":", "?", "@".
#
# set mmonit http://monit:monit@192.168.1.10:8080/collector
#     # and register without credentials     # Don't register credentials
#
#
## Monit by default uses the following format for alerts if the the mail-format
## statement is missing::
## --8<--
## set mail-format {
##   from:    Monit <monit@$HOST>
##   subject: monit alert --  $EVENT $SERVICE
##   message: $EVENT Service $SERVICE
##                 Date:        $DATE
##                 Action:      $ACTION
##                 Host:        $HOST
##                 Description: $DESCRIPTION
##
##            Your faithful employee,
##            Monit
## }
## --8<--
##
## You can override this message format or parts of it, such as subject
## or sender using the MAIL-FORMAT statement. Macros such as $DATE, etc.
## are expanded at runtime. For example, to override the sender, use:
#
# set mail-format { from: monit@foo.bar }
#
#
## You can set alert recipients whom will receive alerts if/when a
## service defined in this file has errors. Alerts may be restricted on
## events by using a filter as in the second example below.
#
# set alert sysadm@foo.bar                       # receive all alerts
#
## Do not alert when Monit starts, stops or performs a user initiated action.
## This filter is recommended to avoid getting alerts for trivial cases.
#
# set alert your-name@your.domain not on { instance, action }
#
#
## Monit has an embedded HTTP interface which can be used to view status of
## services monitored and manage services from a web interface. The HTTP
## interface is also required if you want to issue Monit commands from the
## command line, such as 'monit status' or 'monit restart service' The reason
## for this is that the Monit client uses the HTTP interface to send these
## commands to a running Monit daemon. See the Monit Wiki if you want to
## enable SSL for the HTTP interface.
#
 set httpd port 2812 and
     use address 192.168.1.11  # only accept connection from localhost
#     allow 0.0.0.0        # allow localhost to connect to the server and
     allow admin:monit      # require user 'admin' with password 'monit'
#
###############################################################################
## Services
###############################################################################
##
## Check general system resources such as load average, cpu and memory
## usage. Each test specifies a resource, conditions and the action to be
## performed should a test fail.
#
  check system $HOST
    if loadavg (1min) > 4 then exec "/usr/share/monit/monit_2_tg.py"
    if loadavg (5min) > 2 then exec "/usr/share/monit/monit_2_tg.py"
    if cpu usage > 95% for 10 cycles then exec "/usr/share/monit/monit_2_tg.py"
    if memory usage > 75% then exec "/usr/share/monit/monit_2_tg.py"
    if swap usage > 25% then exec "/usr/share/monit/monit_2_tg.py"


## Check if a file exists, checksum, permissions, uid and gid. In addition
## to alert recipients in the global section, customized alert can be sent to
## additional recipients by specifying a local alert handler. The service may
## be grouped using the GROUP option. More than one group can be specified by
## repeating the 'group name' statement.
#
#  check file apache_bin with path /usr/local/apache/bin/httpd
#    if failed checksum and
#       expect the sum 8f7f419955cefa0b33a2ba316cba3659 then unmonitor
#    if failed permission 755 then unmonitor
#    if failed uid root then unmonitor
#    if failed gid root then unmonitor
#    alert security@foo.bar on {
#           checksum, permission, uid, gid, unmonitor
#        } with the mail-format { subject: Alarm! }
#    group server
#
#
## Check that a process is running, in this case Apache, and that it respond
## to HTTP and HTTPS requests. Check its resource usage such as cpu and memory,
## and number of children. If the process is not running, Monit will restart
## it by default. In case the service is restarted very often and the
## problem remains, it is possible to disable monitoring using the TIMEOUT
## statement. This service depends on another service (apache_bin) which
## is defined above.

### Check Syslog

 check process rsyslogd with pidfile /var/run/rsyslogd.pid
   group system
   group rsyslogd
   start program = "/etc/init.d/rsyslog start"
   stop  program = "/etc/init.d/rsyslog stop"
   if 5 restarts within 5 cycles then timeout
   if 1 restarts within 1 cycles then timeout
   depend on rsyslogd_bin
   depend on rsyslogd_rc
   depend on rsyslog_file

### Rsyslogd required files (optional)

 check file rsyslogd_bin with path /usr/sbin/rsyslogd
   group rsyslogd
   include /etc/monit/templates/rootbin

 check file rsyslogd_rc with path /etc/init.d/rsyslog
   group rsyslogd
   include /etc/monit/templates/rootbin

 check file rsyslog_file with path /var/log/syslog
   group rsyslogd
   # Note: activate the immark plugin for rsyslog if
   # your system is too low on events.
   if timestamp > 65 minutes then exec "/usr/share/monit/monit_2_tg.py"
   if failed permission 640  then unmonitor
   if failed uid root        then unmonitor
   if failed gid adm         then unmonitor

### Check NTPD

 check process NTPD with pidfile /var/run/ntpd.pid
   group system
   group rsyslogd
   start program = "/etc/init.d/ntp start"
   stop  program = "/etc/init.d/ntp stop"
   #if failed port 123 protocol udp then restart
   if 1 restart within 1 cycle then exec "/usr/share/monit/monit_2_tg.py"
   if 5 restarts with 5 cycles then timeout
   depend on ntpd_bin
   depend on ntpd_rc

### NTPD required files (optional)

 check file ntpd_rc with path /etc/init.d/ntp
    group ntpd
	include /etc/monit/templates/rootbin

 check file ntpd_bin with path /usr/sbin/ntpd
   group ntpd
   include /etc/monit/templates/rootbin

### Check Apache2, only HTTP connection here, no SSL cert available

  check process Apache2 with pidfile /var/run/apache2/apache2.pid
	group www
	group apache
    start program = "/usr/sbin/apachectl start" with timeout 60 seconds
    stop program  = "/usr/sbin/apachectl stop"
    if cpu > 60% for 2 cycles then exec "/usr/share/monit/monit_2_tg.py"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 200.0 MB for 5 cycles then restart
    if children > 25 then restart
    if loadavg(5min) greater than 6 for 8 cycles then stop
    if failed host nimbus.go.ro port 8080 protocol http
       and request "/cloud/status.php" with content = "Nimbus"
    then exec "/usr/share/monit/monit_2_tg.py"
	if 1 restart within 1 cycles then exec "/usr/share/monit/monit_2_tg.py"
	if 3 restarts within 5 cycles then unmonitor
#    if failed port 443 protocol https with timeout 15 seconds then restart
#    if 3 restarts within 5 cycles then unmonitor
    depends on apache_bin
	depends on apache_rc

### Apache2 dependant files

  check file apache_bin with path /usr/sbin/apache2
	group apache
	include /etc/monit/templates/rootbin

  check file apache_rc with path /etc/init.d/apache2
  	group apache
	include /etc/monit/templates/rootbin

### Check SSH

  check process SSH with pidfile /var/run/sshd.pid
    start program = "/bin/systemctl start ssh" with timeout 60 seconds
    stop program  = "/bin/systemctl stop ssh"
    if cpu > 60% for 2 cycles then exec "/usr/share/monit/monit_2_tg.py"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 200.0 MB for 5 cycles then restart
    if loadavg(5min) greater than 6 for 8 cycles then stop
    #if failed port 4443 protocol ssh with timeout 15 seconds then restart
	if failed port 4443 protocol ssh with timeout 15 seconds then exec "/usr/share/monit/monit_2_tg.py"
	if 1 restart within 1 cycle then exec "/usr/share/monit/monit_2_tg.py"
    if 3 restarts within 5 cycles then unmonitor
    group server

### Check Redis

  check process Redis with pidfile /var/run/redis/redis-server.pid
    start program = "/bin/systemctl start redis-server" with timeout 60 seconds
    stop program  = "/bin/systemctl stop redis-server"
    if cpu > 60% for 2 cycles then exec "/usr/share/monit/monit_2_tg.py"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 400.0 MB for 5 cycles then restart
    if loadavg(5min) greater than 6 for 8 cycles then stop
	if 1 restart within 1 cycle then exec "/usr/share/monit/monit_2_tg.py"
    if 3 restarts within 5 cycles then unmonitor
    group server

### Check MariaDB

  check process MariaDB with pidfile /var/run/mysqld/mysqld.pid
	group database
	group mysql
	start program = "/etc/init.d/mysql start"
	stop  program = "/etc/init.d/mysql stop"
	if failed host localhost port 3306 protocol mysql with timeout 15 seconds for 3 times within 4 cycles then restart
	if failed unixsocket /var/run/mysqld/mysqld.sock protocol mysql for 3 times within 4 cycles then restart
	if 5 restarts with 5 cycles then timeout
    if cpu > 60% for 2 cycles then exec "/usr/share/monit/monit_2_tg.py"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 300.0 MB for 5 cycles then restart
    if loadavg(5min) greater than 6 for 8 cycles then stop
	if 1 restart within 1 cycle then exec "/usr/share/monit/monit_2_tg.py"
    if 3 restarts within 5 cycles then unmonitor
	depends on mysql_bin
	depends on mysql_rc

  check file mysql_bin with path /usr/sbin/mysqld
	group mysql
	include /etc/monit/templates/rootbin

  check file mysql_rc with path /etc/init.d/mysql
	group mysql
	include /etc/monit/templates/rootbin

### Check MariaDB log

  check file mysql-error-log with path /var/log/mysql/error.log
	if match "FATAL|ERROR|WARNING" then exec "/usr/share/monit/monit_2_tg.py"

### Check Fail2Ban

  check process Fail2Ban with pidfile /var/run/fail2ban/fail2ban.pid
  	group services
	start program = "/etc/init.d/fail2ban force-start"
	stop  program = "/etc/init.d/fail2ban stop"
	if failed unixsocket /var/run/fail2ban/fail2ban.sock then restart
    if cpu > 60% for 2 cycles then exec "/usr/share/monit/monit_2_tg.py"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 300.0 MB for 5 cycles then restart
    if loadavg(5min) greater than 6 for 8 cycles then stop
	if 1 restart within 1 cycle then exec "/usr/share/monit/monit_2_tg.py"
    if 3 restarts within 5 cycles then unmonitor

### Check Fail2ban log

  check file fail2ban_log with path /var/log/fail2ban.log
	if match "ERROR|WARNING" then exec "/usr/share/monit/monit_2_tg.py"

### Check OpenVPN

  check process OpenVPN with pidfile /var/run/openvpn/server.pid
    start program = "/bin/systemctl start openvpn" with timeout 60 seconds
    stop program  = "/bin/systemctl stop openvpn"
    if cpu > 60% for 2 cycles then exec "/usr/share/monit/monit_2_tg.py"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 300.0 MB for 5 cycles then restart
    if loadavg(5min) greater than 6 for 8 cycles then stop
	if 1 restart within 1 cycle then exec "/usr/share/monit/monit_2_tg.py"
    if 3 restarts within 5 cycles then unmonitor
    group server

### Check openvpn@server

  check process OpenVPN-at-server with pidfile /var/run/openvpn/server.pid
    start program = "/bin/systemctl start openvpn@server" with timeout 60 seconds
    stop program  = "/bin/systemctl stop openvpn@server"
    if cpu > 60% for 2 cycles then exec "/usr/share/monit/monit_2_tg.py"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 300.0 MB for 5 cycles then restart
    if loadavg(5min) greater than 6 for 8 cycles then stop
	if 1 restart within 1 cycle then exec "/usr/share/monit/monit_2_tg.py"
    if 3 restarts within 5 cycles then unmonitor
    group server

### Check ING Telegram Bot

check process ING_BOT
	matching "bot_ing.py"
    start program = "/bin/systemctl start bot_ing" with timeout 60 seconds
    stop program  = "/bin/systemctl stop bot_ing"
    if cpu > 60% for 2 cycles then exec "/usr/share/monit/monit_2_tg.py"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 300.0 MB for 5 cycles then restart
    if loadavg(5min) greater than 6 for 8 cycles then stop
	if 1 restart within 1 cycle then exec "/usr/share/monit/monit_2_tg.py"
    if 3 restarts within 5 cycles then unmonitor
    group server

## Check filesystem permissions, uid, gid, space and inode usage. Other services,
## such as databases, may depend on this resource and an automatically graceful
## stop may be cascaded to them before the filesystem will become full and data
## lost.

### Check '/' FS

  check filesystem rootfs with path /
    #if failed uid root then unmonitor
    #if failed gid disk then unmonitor
    if space usage > 80% for 5 times within 5 cycles then exec "/usr/share/monit/monit_2_tg.py"
    if space usage > 90% then exec "/usr/share/monit/monit_2_tg.py"
    if inode usage > 1800000 then exec "/usr/share/monit/monit_2_tg.py"
    if inode usage > 99% then exec "/usr/share/monit/monit_2_tg.py"
    group server

### Check '/mnt/store' FS

  check filesystem store with path /mnt/store
    #start program  = "/bin/mount /mnt/store"
    #stop program  = "/bin/umount /mnt/store"
    #if failed permission 660 then unmonitor
    #if failed uid root then unmonitor
    #if failed gid disk then unmonitor
    if space usage > 96% for 5 times within 5 cycles then exec "/usr/share/monit/monit_2_tg.py"
    if space usage > 99% then exec "/usr/share/monit/monit_2_tg.py"
    if inode usage > 3700000 then exec "/usr/share/monit/monit_2_tg.py"
    if inode usage > 99% then exec "/usr/share/monit/monit_2_tg.py"
    group server
#
#
## Check a file's timestamp. In this example, we test if a file is older
## than 15 minutes and assume something is wrong if its not updated. Also,
## if the file size exceed a given limit, execute a script
#
### NOTIFICATION TESTS

#  check file TEST_FILE with path /home/pi/projects/none.txt
#	if not exist then exec "/usr/share/monit/monit_2_tg.py"

### Check ING currency bot log

  check file ING_BOT_LOG with path /home/pi/projects/ING_sell/telegram/bot-ing.log
  	start program = "/bin/systemctl start bot_ing"
### Needs a timeout after stop, so the thread can stop...
	stop program = "/bin/systemctl stop bot_ing"
	if match "ERROR|WARNING" then restart
	if 1 restart within 1 cycle then exec "/usr/share/monit/monit_2_tg.py"
	if 3 restarts within 5 cycles then unmonitor

### Check web scraping script SQLITE DB

  check file INGB_DB with path /home/pi/projects/ING_sell/sqlite_db/ING
    if failed permission 644 then exec "/usr/share/monit/monit_2_tg.py"
    if failed uid pi then exec "/usr/share/monit/monit_2_tg.py"
    if failed gid pi then exec "/usr/share/monit/monit_2_tg.py"
    if timestamp > 20 minutes then exec "/usr/share/monit/monit_2_tg.py"
	if size > 100 MB then exec "/usr/share/monit/monit_2_tg.py"
    #if size > 100 MB then exec "/my/cleanup/script" as uid dba and gid dba
	
### Check redis.socket file permissions

  check file redis_socket with path /var/run/redis/redis.sock
    if failed permission 775 then exec "/usr/share/monit/monit_2_tg.py"
    if failed uid "redis" then exec "/usr/share/monit/monit_2_tg.py"
    if failed gid www-data then exec "/usr/share/monit/monit_2_tg.py"
    #if size > 100 MB then exec "/my/cleanup/script" as uid dba and gid dba
#
#
#
## Check directory permission, uid and gid.  An event is triggered if the
## directory does not belong to the user with uid 0 and gid 0.  In addition,
## the permissions have to match the octal description of 755 (see chmod(1)).
#
#  check directory bin with path /bin
#    if failed permission 755 then unmonitor
#    if failed uid 0 then unmonitor
#    if failed gid 0 then unmonitor
#
#
## Check a remote host availability by issuing a ping test and check the
## content of a response from a web server. Up to three pings are sent and
## connection to a port and an application level network check is performed.
#
### Check ROCK64

  check host ROCK64 with address 192.168.1.15
    if failed ping then exec "/usr/share/monit/monit_2_tg.py"
    if failed port 2828 protocol ssh then exec "/usr/share/monit/monit_2_tg.py"
    if failed port 80 protocol http
       and request /cloud/status.php with content = "Nimbus"
    then exec "/usr/share/monit/monit_2_tg.py"
    if failed port 443 protocol https
	   and request /cloud/status.php with content = "Nimbus"
	then exec "/usr/share/monit/monit_2_tg.py"

### Check ROCK64

check host ROCK64.wifi with address 192.168.1.14
    if failed ping then exec "/usr/share/monit/monit_2_tg.py"

#
#
## Check a network link status (up/down), link capacity changes, saturation
## and bandwidth usage.
#
### Check PISKY interfaces

  check network wired with interface eth0
    if failed link then exec "/usr/share/monit/monit_2_tg.py"
    if changed link then exec "/usr/share/monit/monit_2_tg.py"
    if saturation > 90% then exec "/usr/share/monit/monit_2_tg.py"
    if download > 10 MB/s then exec "/usr/share/monit/monit_2_tg.py"
    if total uploaded > 1 GB in last hour then exec "/usr/share/monit/monit_2_tg.py"

  check network wifi with interface wlan0
    if failed link then exec "/usr/share/monit/monit_2_tg.py"
    if changed link then exec "/usr/share/monit/monit_2_tg.py"
    if saturation > 90% then exec "/usr/share/monit/monit_2_tg.py"
    if download > 10 MB/s then exec "/usr/share/monit/monit_2_tg.py"
    if total uploaded > 1 GB in last hour then exec "/usr/share/monit/monit_2_tg.py"

#
#
## Check custom program status output.
#
#  check program myscript with path /usr/local/bin/myscript.sh
#    if status != 0 then alert
#
#
###############################################################################
## Includes
###############################################################################
##
## It is possible to include additional configuration parts from other files or
## directories.
#
   include /etc/monit/conf.d/*
   include /etc/monit/conf-enabled/*
